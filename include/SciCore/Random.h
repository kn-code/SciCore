//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
//

///
/// \file   Random.h
///
/// \brief  Generation of pseudo random numbers.
///

#ifndef SCICORE_RANDOM_H
#define SCICORE_RANDOM_H

#include <random>

#include "Definitions.h"

namespace SciCore
{

///
///  \defgroup Random Random number generation
///
///  \brief Extends the C++ random number capabilities with more efficient PRNGs and vector/matrix capabilities
///
///  This module extends the C++ random number capabilities with more efficient PRNGs and vector/matrix capabilities.
///
///  \snippet tests/RandomTest.cpp random_example
///
///  \{
///

uint64_t splitMix64(uint64_t x) noexcept;

///
/// \brief Implements the <a href="http://xoshiro.di.unimi.it">xoshiro256 PRNG</a>.
///
/// This class implements the <a href="http://xoshiro.di.unimi.it">xoshiro256 PRNG</a>.
/// It can be used with the random number distributions defined in the standard library
/// \a random but is much faster than the random number generators contained therein.
/// Note that it is not cryptographically secure.
///
/// \headerfile Random.h <SciCore/Random.h>
///
class Xoshiro256
{

  public:
    ///
    /// \brief The integral type generated by the engine.
    ///
    using result_type = uint64_t;

    ///
    /// \brief Creates a seeded PRNG. The seed is created using \a std::random_device.
    ///
    Xoshiro256() noexcept;

    ///
    /// \brief Creates a seeded PRNG.
    ///
    /// \copybrief Xoshiro256(uint64_t seed)
    ///
    /// \param seed The used seed.
    ///
    Xoshiro256(uint64_t seed) noexcept;

    ///
    /// \brief Returns the next random number as an \a uint64_t in the range [0, \a
    /// std::numeric_limits<uint64_t>::max()].
    ///
    uint64_t operator()() noexcept;

    ///
    /// \brief Returns the next random number as a \a double in the range [0, 1].
    ///
    inline double getDouble() noexcept
    {
        return 5.42101086242752217E-20 * this->operator()();
    }

    ///
    /// \brief The jump function for the generator.
    ///
    /// This function is equivalent to 2^128 calls to operator()(); it can be used to generate 2^128
    /// non-overlapping subsequences for parallel computations.
    ///
    void jump() noexcept;

    ///
    /// \brief The long jump function for the generator.
    ///
    /// This function is equivalent to 2^192 calls to operator()(); it can be used to generate 2^64 starting points,
    /// from each of which jump() will generate 2^64 non-overlapping subsequences for parallel distributed computations.
    ///
    void longJump() noexcept;

    ///
    /// \brief Returns the minimum value that can be returned by operator()().
    ///
    static constexpr uint64_t min() noexcept
    {
        return 0;
    }

    ///
    /// \brief Returns the maximum value that can be returned by operator()().
    ///
    static constexpr uint64_t max() noexcept
    {
        return std::numeric_limits<uint64_t>::max();
    }

  private:
    uint64_t s[4];

    inline constexpr uint64_t rotl(uint64_t x, int k) noexcept
    {
        return (x << k) | (x >> (64 - k));
    }
};

///
/// \brief      Returns a randomly filled matrix.
///
/// \copybrief randomMatrix()
///
/// \param      rows         Number of rows of the matrix.
/// \param      columns      Number of columns of the matrix.
/// \param      dis          The distribution used to generate the random numbers,
///                          for example, _std::uniform_real_distribution_.
/// \param      rnd          The random number generator, for example Xoshiro256.
///
template <DenseMatrixType MatrixT, typename RandomDistT, typename RandomGenT>
MatrixT randomMatrix(int rows, int columns, RandomDistT& dis, RandomGenT& rnd)
{
    MatrixT returnValue(rows, columns);
    for (int j = 0; j < returnValue.cols(); ++j)
    {
        for (int i = 0; i < returnValue.rows(); ++i)
        {
            if constexpr (IsComplexMatrix<MatrixT>::value == true)
            {
                returnValue(i, j).real(dis(rnd));
                returnValue(i, j).imag(dis(rnd));
            }
            else
            {
                returnValue(i, j) = dis(rnd);
            }
        }
    }
    return returnValue;
}

// clang-format off
#ifndef SCICORE_DONT_PRECOMPILE_TEMPLATES
extern template RealMatrix randomMatrix<RealMatrix, std::uniform_real_distribution<Real>, SciCore::Xoshiro256>(int, int, std::uniform_real_distribution<Real>&, SciCore::Xoshiro256&);
extern template Matrix randomMatrix<Matrix, std::uniform_real_distribution<Real>, SciCore::Xoshiro256>(int, int, std::uniform_real_distribution<Real>&, SciCore::Xoshiro256&);
#endif // SCICORE_DONT_PRECOMPILE_TEMPLATES
// clang-format on

///
/// \brief      Returns a randomly filled vector.
///
/// \copybrief randomVector()
///
/// \param      size         The size of the vector.
/// \param      dis          The distribution used to generate the random numbers,
///                          for example, _std::uniform_real_distribution_.
/// \param      rnd          The random number generator, for example Xoshiro256.
///
template <DenseMatrixType VectorT, typename RandomDistT, typename RandomGenT>
inline VectorT randomVector(int size, RandomDistT& dis, RandomGenT& rnd)
{
    static_assert(VectorT::RowsAtCompileTime == 1 || VectorT::ColsAtCompileTime == 1, "Invalid vector type.");
    if constexpr (VectorT::RowsAtCompileTime == 1)
    {
        return randomMatrix<VectorT>(1, size, dis, rnd);
    }
    else
    {
        return randomMatrix<VectorT>(size, 1, dis, rnd);
    }
}

/// \} // end of Random

} // namespace SciCore

#endif // SCICORE_RANDOM_H
